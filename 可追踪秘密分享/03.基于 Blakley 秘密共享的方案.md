
### 4 基于 Blakley 秘密共享的方案

在本节中，我们展示了如何在 Blakley 开创性秘密共享方案 [6] 的一个变体中追踪泄漏。我们首先提出了 Blakley 原始方案的扩展版本。随后，我们为该扩展方案展示了一种非常高效的追踪算法。

#### 4.1 扩展的 Blakley 方案

我们首先回顾 Blakley 的原始方案 [6]，然后介绍我们扩展的方案。

##### Blakley 原始方案及其局限性

在 Blakley 的方案中，秘密被编码为有限域 $F_p^t$ 中某点的一个坐标，其中 $p$ 是适当选择的模数，$t$ 是阈值。具体而言，分发者（dealer）选择一个随机点 $x \in F_p^t$，条件是其第一个坐标 $x_1$ 等于秘密 $s \in F_p$。随后，分发者为每个参与方 $i$ 分配一个均匀随机的超平面 $H_i \subset F_p^t$，使其通过点 $x$。

当模数 $p$ 足够大时，任意 $t$ 个分配的超平面以高概率会相交于一个唯一的点。由于所有超平面均设计为通过点 $x$，这一唯一的交点必然是 $x$。

关于保密性，注意到任意 $k$ 个超平面的交集是一个维度至少为 $t-k$ 的子空间。因此，当 $k < t$ 时，这一子空间的维度至少为 1。假设为了简单起见，该子空间的维度恰好为 1，即它是 $F_p^t$ 中的一条直线 $\ell$。如果 $\ell$ 不垂直于第一个坐标轴（这种情况发生的概率非常小），则 $\ell$ 上的所有点的第一个坐标都不同。

直观上，这意味着直线 $\ell$ 不会泄露点 $x$ 的第一个坐标的任何信息，因此不会泄露秘密 $s \in F_p$。我们将在扩展 Blakley 方案时对这一点进行严格论证。

然而，在我们的追踪程序中，我们需要将秘密编码为 $F_p^t$ 中的一个完整点。Blakley 方案的一个简单扩展可能会将秘密 $s \in F_p^t$ 直接设置为所有超平面的交点。然而，这种简单扩展完全不安全！注意，即使只有一个超平面（即一个共享）也会泄露大量关于秘密的信息，因为它仅包含 $F_p^t$ 中点的 $1/p$ 的比例。

更一般地讲，可以很容易地看出，如果我们将秘密设置为交点 $x \in F_p^t$ 的前 $k$ 个坐标，那么只需 $t-k+1$ 个超平面就能泄露关于秘密的信息。


##### 扩展的 Blakley 方案

为了避免上述的简单扩展，我们采用了一种更精巧的方法，通过引入更多的随机性，将秘密“分散”到交点 $x$ 的多个分量中。具体来说，假设我们希望将秘密编码为 $F_p^t$ 中的一个完整点。其核心思想是使用标准的加法秘密共享方式，将秘密 $s$ 随机分成 $t$ 份 $r_1, \ldots, r_t$，满足：

$$r_1, \ldots, r_t \text{ 在 } F_p^t \text{ 中均匀随机，且 } r_1 + r_2 + \cdots + r_t = s。$$

随后，我们使用前述 Blakley 方案的简单扩展分别共享这些 $r_i$。具体来说，第 $i$ 个秘密共享现在包括 $t$ 个随机超平面 $H_i^{(1)}, \ldots, H_i^{(t)}$，这些超平面分别通过 $r_1, \ldots, r_t$。

---
##### 方案的安全性

从安全性的角度来看，可以将 $t$ 次“简单 Blakley”实例视为发生在 $F_p^t$ 的 $t$ 个正交子空间中。任何 $t-1$ 个参与方的集合持有 $F_p^{t^2}$ 中的 $t \cdot (t-1)$ 个超平面。这种设置能够精确隐藏 $F_p$ 中的 $t$ 个元素。

直观上，这是因为每个“候选秘密” $s^* \in F_p^t$ 增加了 $t$ 个关于 $F_p^t$ 的仿射方程，因此由该秘密和 $t \cdot (t-1)$ 个超平面诱导的仿射方程组包含恰好 $t^2$ 个方程。这意味着方程组不具有过度约束性，从而使 $s^*$ 成为可能的解。

正式的分析需要更复杂的证明过程。

---

##### 方案细节

我们将该方案称为 **Blakley+**，其参数化由一个函数 $p = p(n, t, \lambda)$ 决定，该函数定义了有限域的大小。秘密共享算法的输入包括：
- $n$：参与方数量；
- $t$：阈值；
- 一个秘密向量 $s \in F_p^t$；
- 一个相关性字符串 $\rho$，其被解释为用于对 $s$ 进行加法秘密共享的随机性。

Blakley+ 方案通过这种随机分散和扩展共享的方法，增强了原始方案的安全性，同时确保可以通过一定数量的共享进行秘密重建。

![[BlakleyShare.png]]

重建算法接收 $t$ 个共享并输出一个秘密 $s \in F_p^k$。为简化描述，我们将接收到的共享编号为 $1, \ldots, t$，但该算法对于任意 $t$ 个共享的子集定义完全相同。

![[BlakleyRec.png]]

##### 正确性

令 $n \in \mathbb{N}$ 且 $t \leq n$，秘密 $s \in F_p^t$。设 $sh_1, \ldots, sh_t$ 是通过共享算法 $\text{Share}$ 生成的 $n$ 个共享中任意选出的 $t$ 个共享。我们证明，重建算法 $\text{Rec}(sh_1, \ldots, sh_t) = s$ 的概率很高。

固定 $j \in [t]$，考虑以下方程组：

$$\{\langle a_{i,j}, R_j \rangle = b_{i,j} \}_{i \in [t]}$$

如果 $\{a_{i,j}\}_{i \in [t]}$ 是线性无关的，那么这个方程组有唯一解，该解必然等于共享算法 $\text{Share}$ 中采样的共享 $r_j$。

$\{a_{i,j}\}_{i \in [t]}$ 线性无关的概率为：

$$\prod_{\ell=0}^{t-1} \frac{p^t - p^\ell}{p^{t^2}} = \prod_{\ell=1}^{t} \left(1 - p^{-\ell}\right) \geq 1 - \sum_{\ell=1}^{t} p^{-\ell} > 1 - \frac{1}{p - 1}$$

通过联合界限（union bound），$\text{Rec}$ 正确计算 $r_1, \ldots, r_k$ 的概率至少为：

$$1 - \frac{t}{p - 1}$$

此外，只要 $r_1, \ldots, r_t$ 被正确计算，秘密 $s$ 也会被正确计算。因此，我们可以将方案的正确性误差界定为：

$$\frac{t}{p - 1}$$

当 $t$ 是多项式规模且 $p$ 是超多项式规模时，该误差可以认为是可忽略的。

---

#### 高效表示超平面

考虑我们的方案中分配给第 $i$ 个参与方的共享。该共享包含 $t$ 对 $\{(a_{i,j}, b_{i,j})\}_{j \in [t]}$，因此其大小为：

$$t \cdot (t+1) \cdot \log p$$

然而，注意到对于每个 $j \in [t]$，$a_{i,j}$ 是 $F_p^t$ 中均匀随机的向量，并且独立于 $\{a_{i,j'}\}_{j' \neq j}$。因此，**我们可以用伪随机生成器 $G$ 的种子 $\sigma_i$ 替代显式表示 $a_{i,j}$。** 然后，在重建秘密时，首先通过计算 $(a_{i,1}, \ldots, a_{i,t}) \leftarrow G(\sigma_i)$ 展开 $\sigma_i$ 为 $a_{i,j}$，之后按照正常流程进行。这种方法将共享的大小减少为：

$$\lambda + t \cdot \log p$$

代价是只能实现计算安全性（computational secrecy）。

**另一种选择是使用 $\varepsilon$-偏置集合（$\varepsilon$-biased sets）[53, 1, 67] 来高效表示 $(a_{i,1}, \ldots, a_{i,t})$。** 这种方法可以将共享大小减少为：

$$\log(t^2 \log p) + O(\alpha) + k \cdot \log p$$

但会引入一个额外的统计安全性损失 $n \cdot 2^{-\alpha}$。

最后，**正如 Brikell [16] 所观察到的，所有 $a_{i,j}$（或其高效表示）都可以公开**，而不会影响安全性。如果这样做，那么每个参与方需要存储的秘密信息的大小仅为：

$$t \cdot \log p$$

这恰好等于秘密的大小，使得我们的扩展 Blakley 方案成为理想方案（即秘密共享的大小与秘密相同）。


### 4.2 基本追踪过程

我们现在介绍扩展 Blakley 方案的追踪算法。首先，我们描述一种追踪算法，该算法依赖于所有分配给各方的秘密共享 $sh_1, \ldots, sh_n$ 的完整知识。在接下来的部分中，我们将展示如何（略微）修改追踪密钥和追踪算法，使得追踪过程无需明确知道秘密共享，从而使方案提供**非可归责性**。

我们首先对构造进行非正式概述：

在 Blakley+ 方案中，秘密是一个点 $s \in F_p^t$。为了生成 $n$ 个共享，$\text{Share}$ 算法采样 $r_1, \ldots, r_t$，使其和等于 $s$。对于 $i \in [n]$，第 $i$ 个共享由 $t$ 个随机超平面 $H_i^{(1)}, \ldots, H_i^{(t)}$ 组成，这些超平面分别通过点 $r_1, \ldots, r_t$。

- **追踪密钥（$tk$）**：由 $r_2, \ldots, r_t$ 以及每个参与方的第一个超平面 $H_1^{(1)}, \ldots, H_n^{(1)}$ 组成。
- **验证密钥（$vk$）**：由 $H_i^{(1)}, \ldots, H_i^{(t)}$（每个共享的所有超平面）组成。

为简单起见，在本非正式概述中，我们假设 $t-1$ 个秘密共享被硬编码到重建盒 $R$ 中，而 $R$ 需要一个额外的共享作为输入。

---
#### **追踪过程**

为了对 $R$ 进行追踪，我们根据 $r_1, \ldots, r_t$ 的一致性采样一个随机共享并输入到 $R$ 中。具体而言，对于每个 $j \in [t]$，采样超平面 $H^{(j)}$ 的过程如下：

1. **对于 $j = 2, \ldots, t$**：均匀随机采样一个超平面 $H^{(j)}$，使其通过 $r_j$。
2. **对于 $j = 1$**：均匀随机采样一个超平面 $H^{(1)}$。

追踪算法将共享 $sh = (H^{(1)}, H^{(2)}, \ldots, H^{(t)})$ 输入到 $R$ 中，$R$ 返回某个秘密 $s' \in F_p^t$。

假设 $R$ 是完全正确的（perfectly correct），根据构造我们知道：

1. 对于每个 $j \geq 2$，$H^{(j)}$ 与嵌入到 $R$ 中的共享的第 $j$ 个超平面在 $r_j$ 处相交。
2. 这意味着 $H^{(1)}$ 与嵌入到 $R$ 中的共享的第一个超平面在点：

$$r_1' = s' - (r_2 + \cdots + r_t)$$

处相交。

==追踪算法因此输出所有满足 $r_1'$ 在其第一个超平面 $H_i^{(1)}$ 上的参与方 $i \in [n]$。==

![[BlakleyShareExpress.jpg]]

---
#### **追踪准确性**

- **捕获被破坏的参与方**：由于 $R$ 是正确的，任何其共享被硬编码到 $R$ 的参与方 $i$，其 $r_1'$ 必然位于其第一个超平面 $H_i^{(1)}$ 上。因此，所有被破坏的参与方都能被追踪算法捕获。
- **避免诬陷诚实参与方**：如果某个参与方 $i$ 是诚实的，则 $r_1'$ 与 $H_i^{(1)}$ 统计上独立，因此 $r_1'$ 位于 $H_i^{(1)}$ 上的概率非常小，从而不会错误指控诚实的参与方。

---

#### **完整算法**

在详细的追踪算法中，为简单起见，我们假设输入包括被硬编码到 $R$ 中的损坏共享的数量 $f < t$。这种假设可以通过与第 3 节相同的方法移除，从而实现无需额外假设的追踪过程。

![[Pasted image 20241117205402.png]]

**验证算法 (Verify):**

验证算法接受一个验证密钥 $vk = \{(a_{1,1}, b_{1,1}), \dots, (a_{n,1}, b_{n,1})\}$、一个子集 $I$ 和一个证明 $\pi = \{(a'_{i,1}, b'_{i,1})\}_{i \in I}$。如果且仅如果 $I$ 和 $\pi$ 与 $vk$ 一致，即对所有 $i \in I$ 满足 $(a'_{i,1}, b'_{i,1}) = (a_{i,1}, b_{i,1})$，则输出 1，否则输出 0。

**对追踪过程的影响：**

这种验证方式使得追踪器可以轻松地伪造证据，将无辜的参与方栽赃为泄密者。然而，正如作者提到的，他们将在后续部分展示如何解决这一问题。

**完整方案 (TB)：**

本文定义的可追踪秘密分享方案 $TB$ 包括以下算法：  
- $Share$ 和 $Rec$：在 4.1 节定义，且 $Share$ 输出 $tk$ 和 $vk$。
- $Trace$ 和 $Verify$：在本节描述。

**TB 的追踪性：**

论文通过以下定理证明了 TB 在分区 $\Gamma_{\text{sngltn}} = \{\{(r_2, \dots, r_t)\} : r_2, \dots, r_t \in \mathbb{F}_p^t\}$ 下是全局可追踪的。

**定理 5**：对任意对手 $A$、任意 $\lambda \in \mathbb{N}$、任意 $\varepsilon \in [0, 1]$，有：
$$\text{Adv}_{\text{uni-trac}}^{A, TB, \Gamma_{\text{sngltn}}, \varepsilon}(\lambda) \leq e^{-\lambda} + \frac{2n \lambda}{\varepsilon p},$$
其中 $n = n(\lambda)$ 是参与方的最大数量，且假设 $p \geq 2n / \varepsilon$。

### 4.3 增加非可归责性

在上文描述的方案中，掌握追踪密钥 $tk$ 可以轻松地伪造证据，错误地指控某个无辜方将其共享贡献给盗版重建盒 $R$。这违反了**非可归责性**（定义 6）。原因在于，$tk$ 以明文形式包含了每个参与方的第一个超平面 $(a_{i,1}, b_{i,1})$。

接下来我们说明，这种明文信息并非必要。我们观察到，追踪过程并不需要完整知道 $(a_{i,1}, b_{i,1})$，仅需要能够判断某一点（即由追踪算法 $\text{Trace}$ 重建出的 $r_1$）是否位于由 $(a_{i,1}, b_{i,1})$ 确定的超平面上。

为实现这一目的，只需将 $(a_{i,1}, b_{i,1})$ 的信息以某种方式隐藏起来即可。具体做法如下：
- $a_{i,1}$ 可以表示为 $((a_{i,1})_1, \ldots, (a_{i,1})_t)$。
- 通过一个同态单向函数 $f$，计算并存储 $f((a_{i,1})_1), \ldots, f((a_{i,1})_t)$ 和 $f(b_{i,1})$。

追踪密钥 $tk$ 和验证密钥 $vk$ 会包含这些 $f$ 的评估值，而 $tk$ 还会包含之前定义的 $r_2, \ldots, r_t$。

---

#### **同态性如何支持非可归责性**

利用同态性，追踪算法 $\text{Trace}$ 可以在隐藏的 $f$-空间中验证 $\langle a_{i,1}, r_1 \rangle = b_{i,1}$ 是否成立，而无需直接知道 $a_{i,1}$ 和 $b_{i,1}$ 的明文值。验证算法 $\text{Verify}$ 同样可以进行这种检查。

---

#### **直观理解**

如果某个参与方 $i$ 是诚实的，则重建盒 $R$ 与 $a_{i,1}$ 在统计上是独立的。因此，错误地指控参与方 $i$ 涉嫌泄密，需要在 $f((a_{i,1})_1), \ldots, f((a_{i,1})_t)$ 和 $f(b_{i,1})$ 中找到某种非平凡的线性关系，而这等价于反转单向函数 $f$。由于单向函数 $f$ 是安全的，攻击者无法找到这种关系，从而确保非可归责性。


我们现在详细介绍追踪和验证算法的更改，并证明其满足**非可归责性**。为了具体说明，我们假设同态单向函数 $f$ 是循环群中的指数运算，其单向性基于离散对数问题在群中的困难性。从渐近分析的角度，我们考虑分布在离散对数难解群上的分布族。这通过一个群生成算法 $G$ 形式化，算法接受安全参数作为输入，并输出一个三元组 $(G, g, p)$，其中 $G$ 是一个由 $g$ 生成的阶为 $p$ 的群的描述。

我们还使用以下标准记号：
1. 对于群元素 $h \in G$ 和向量 $x = (x_1, \ldots, x_\ell)$（元素来自 $\mathbb{Z}_p$），定义 $h^x$ 为向量 $(h^{x_1}, \ldots, h^{x_\ell})$。
2. 对于群元素向量 $h = (h_1, \ldots, h_\ell)$ 和向量 $x$，定义 $h^x := \prod_i h_i^{x_i}$。

---

#### **方案更改如下：**

1. **共享算法的更改**  
   $\text{Share}(1^\lambda, s, n, t)$ 现在会采样一个群 $(G, g, p) \leftarrow G(1^\lambda)$。然后计算 $r_1, \ldots, r_t$ 和 $sh_i = \{(a_{i,j}, b_{i,j})\}_{j \in [t]}$（与之前一致）。  
   共享算法进一步计算：
   $$y_i \gets g^{a_{i,1}}, \quad z_i \gets g^{b_{i,1}}, \quad \text{对于每个 } i \in [n]。$$
   然后设置：
   $$tk \gets ((G, g, p), r_2, \ldots, r_t, y_1, \ldots, y_n, z_1, \ldots, z_n)$$
   $$vk \gets ((G, g, p), y_1, \ldots, y_n, z_1, \ldots, z_n)$$

2. **追踪算法的更改**  
   追踪算法 $\text{Trace}$ 按照之前的方法计算 $r_1$，并将被损坏方的索引集合 $I$ 设置为满足以下条件的所有索引 $i$：
   $$y_i^{r_1} = z_i。$$
   证明 $\pi$ 现在是向量 $r_1$。

3. **验证算法的更改**  
   验证算法 $\text{Verify}$ 用于验证证明 $\pi = r_1$ 是否与子集 $I$ 一致。具体步骤为：
   - 检查是否对所有 $i \in I$，有 $y_i^{r_1} = z_i$；
   - 检查是否存在 $i' \in [n] \setminus I$，使得 $y_{i'}^{r_1} \neq z_{i'}$。  
   验证算法仅当上述两个条件同时满足时输出 1。

---

#### **新方案的命名**

经过这些更改后，新的方案称为 **NITB**（代表“Non-Imputable Traceable Blakley”）。

---

#### **正确性、保密性和追踪性**

NITB 的正确性、保密性和追踪性可以通过与前述小节相同的分析证明。我们现在进一步证明 NITB 还满足**非可归责性**。

---

#### **非可归责性证明**

非可归责性的证明通过将其归约为在群 $G$ 中找到随机群元素之间非平凡的线性关系问题。具体而言：
- 如果某个诚实参与方 $i$ 被错误指控，则需要在 $y_i = g^{a_{i,1}}$ 和 $z_i = g^{b_{i,1}}$ 的加密表示中找到线性关系；
- 由于 $g^{a_{i,1}}$ 和 $g^{b_{i,1}}$ 是由单向函数生成的随机群元素，找到这样的线性关系等价于反转离散对数问题，这是困难的。

因此，NITB 方案能够在保证非可归责性的同时，实现正确性、保密性和追踪性。

#### 定义 11

设 $G$ 是一个群生成算法，$\ell = \ell(\lambda)$ 是安全参数 $\lambda \in \mathbb{N}$ 的函数。我们称**离散对数关系（Discrete-Log Relation, DLR）问题**相对于 $G$ 是困难的，如果对任意概率多项式时间算法 $A$，都存在一个可忽略函数 $\nu(\cdot)$，使得：

$$\text{Adv}_{\text{dlr}}^{A,G}(\lambda) := \Pr\left[\langle a, r \rangle = 0 \land r \neq 0 : (G, p, g) \leftarrow G(1^\lambda), a \leftarrow \mathbb{Z}_p^\ell, r \leftarrow A((G, p, g), g^a)\right] < \nu(\lambda)$$

对所有 $\lambda \in \mathbb{N}$ 成立。

---

#### DLR 与离散对数问题的等价性

一个简单的归约表明，在 $G$ 中的 DLR 问题与离散对数问题是紧密等价的（参见例如 [15]）。

---
#### 定理 6

对于 NITB 的非可归责性攻击者 $A$，存在一个针对 DLR 问题的算法 $B$，使得对任意 $\lambda \in \mathbb{N}$，都有：

$$\text{Adv}_{\text{ni}}^{A,\text{NITB}}(\lambda) = \text{Adv}_{\text{dlr}}^{B,G}(\lambda)。$$


