---
width: "2560"
---
### 3.1 我们方案的概述

##### 随机评估点

在传统的 Shamir 秘密共享方案中，每个参与方 $i$ 都被确定性地分配了一个评估点 $x_i$。最简单的例子是，当有限域 $F$ 是模 $p$ 的整数域 $F_p$ 时，自然的选择是令 $x_i = i$，其中 $i$ 被解释为 $F_p$ 中的一个元素。

我们首先观察到，这种方法在我们的定义下无法支持高效的追踪。这是因为一个对手可能会破坏一部分随机的参与方集合 $I$，并利用集合 $I$ 中的秘密分享构造一个重建盒 $R$。设 $f = |I|$。当 $R$ 接收到来自 $I$ 之外的 $t-f$ 个参与方的分享时，它会输出秘密 $s$；但同时，$R$ 可以将其输入的分享 $(x_i, q(x_i))$ 与参与方 $i$ 关联起来，因为 $x_i$ 是参与方索引 $i$ 的确定性函数。如果 $R$ 接收到的输入多于 $t-f$ 个分享，或者输入中包含属于集合 $I$ 的某个分享，$R$ 将输出 $\perp$ （表示无效结果），并拒绝输出任何有意义的内容。

---
在这种情况下，无论追踪策略如何，$R$ 输出非 $\perp$ 的概率最多为：

$$\approx Q \cdot \frac{\binom{n-(t-f)}{f}}{\binom{n}{f}}$$

其中，$Q$ 是追踪算法对 $R$ 发起的查询次数。为了说明这一点，我们考虑一个不同的实验：在该实验中，追踪者始终从 $R$ 接收到 $\perp$，但如果追踪者在某个不与损坏集合 $I$ 相交的子集上查询 $R$，我们仍然认为追踪者获胜。在这种修改后的实验中，由于追踪者的视角在获胜之前与原实验相同，所以追踪者获胜的概率与原实验相同。

---
在这个修改后的实验中，追踪者的查询与损坏集合 $I$ 无关，因此可以认为 $I$ 在所有查询确定后均匀随机选择。此时，集合 $I$ 不与大小为 $t-f$ 的特定子集相交的概率为：

$$\frac{\binom{n-(t-f)}{f}}{\binom{n}{f}}$$

因此，追踪者获胜的总体概率上限为 $Q \cdot \frac{\binom{n-(t-f)}{f}}{\binom{n}{f}}$。例如，当 $t = c_1 n$ 且 $f = c_2 t$ （其中 $c_1, c_2 \in (0, 1)时，如果 Q$ 是 $n$ 的多项式，则期望让 $R$ 输出非 $\perp$ 需要 $2^{\Omega(n)}$ 次查询。

---
为了避免这个问题，我们考虑 Shamir 秘密共享的一种变体，其中每个 $x_i$ 是从域 $F$ 中均匀随机采样的。如果域 $F$ 足够大，这对方案的正确性影响非常小。还可以使用拒绝采样来减少甚至消除由于将相同的 $x$ 分配给两个不同的参与方而导致的小正确性误差。

这种方法的优点是，现在的分享 $(x_i, q(x_i))$ 无法在未知经销商随机性的情况下直接关联到参与方 $i$。正如我们将看到的，这使我们能够克服上述的不可能性论证。

---
#### 通过多项式插值和因式分解进行追踪

为了理解我们追踪过程背后的基本思想，可以考虑 Shamir 秘密共享中盗版重建盒 $R$ 所需要完成的任务。为简单起见，假设损坏的份额数量为 $f = t-1$。在这种情况下，$R$ 接收一个额外的份额作为输入，并输出秘密 $s$。这个秘密是通过使用 $R$ 内硬编码的 $t-1$ 个 $q$ 的评估值以及额外的评估值来重建 $q(0)$ 的结果。

---

假设 $R$ 中硬编码的份额是 $(x_i, y_i = q(x_i))$，其中 $i = 1, \ldots, t-1$。当给 $R$ 一个额外的形式为 $(x_t, y_t)$ 的份额时，$R$ 需要输出：

$$s = \sum_{i \in [t]} \left( \prod_{k \in [t] \setminus \{i\}} \frac{x_k}{x_k - x_i} \right) \cdot y_i$$

否则，$R$ 就不是一个良好的重建盒。该公式可以重新写成：

$$s = \sum_{i \in [t-1]} \left( \prod_{k \in [t] \setminus \{i\}} \frac{x_k}{x_k - x_i} \right) \cdot y_i + \left( \prod_{k \in [t-1]} \frac{x_k}{x_k - x_t} \right) \cdot y_t \tag{1}$$

---
如果我们将形式为 $(x_t, y_t + 1)$ 的份额提供给 $R$，其中 $x_t$ 和 $y_t$ 保持不变，则得到另一个 $s'$ 满足：

$$s' = \sum_{i \in [t-1]} \left( \prod_{k \in [t] \setminus \{i\}} \frac{x_k}{x_k - x_i} \right) \cdot y_i + \left( \prod_{k \in [t-1]} \frac{x_k}{x_k - x_t} \right) \cdot (y_t + 1) \tag{2}$$

将公式 (1) 从公式 (2) 中相减并重排，得到：

$$\prod_{k \in [t-1]} \frac{x_k - x_t}{x_k} = (s' - s)^{-1} \tag{3}$$

---
我们现在考虑单变量多项式 $h(X) = \prod_{k \in [t-1]} \frac{x_k - X}{x_k}$，其变量为 $X$。可以观察到，$h$ 的根正是被损坏参与方的 $x_i$ 值。此外，我们可以将公式 (3) 解释为 $h$ 在点 $x_t$ 的评估值。

通过重复上述过程，对 $R$ 进行额外 $t-1$ 次新鲜的 $x_t$ 值查询，可以获得 $h$ 的 $t$ 个评估值。由于 $h$ 是一个 $t-1$ 次多项式，这些评估值足够通过插值重建 $h$ 并因式分解以找到其根（即 [5, 61, 47] 提到的多项式因式分解方法）。如果追踪器 $tk$ 包含所有参与方的真实 $x_i$ 值，则可以将 $h$ 的根追踪回被损坏的参与方。

#### 分发与重建

该方案以有限域 $F = F(\lambda, n, t)$ 为参数。我们首先介绍共享算法（Share）。该算法的输入包括：

- 安全参数 $1^\lambda$；
- 秘密 $s \in F$；
- 整数 $n$ 和 $t$；
- 一个相关性字符串 $\rho$，它被解释为有限域 $F$ 中的 $t-1$ 个系数。
![[shamirShare1.png]]![[shamirShare2.png]]


重建算法是标准的 Shamir 重建算法，同时考虑到 $x_i$ 的随机选择。为了简化描述，我们假定共享的编号为 $1, \ldots, t$，并且假定对于 $1 \leq i < j \leq t$，总有 $x_i \neq x_j$。这种假设确保了多项式插值的唯一性。 
![[shamirRec.png]]

---

这一部分描述了 TS 方案的基本分发和重建流程，其中分发算法生成秘密共享，重建算法使用这些共享重建出秘密。随机选择的 $x_i$ 是该方案的关键特性之一，用于防止共享之间的简单关联，同时确保多项式插值的正确性。

---
### 3.2 追踪不完美重构盒
我们现在描述我们的追踪算法。请注意，前一节中的非正式概述本质上假设了重构盒 $R$ 始终是正确的，特别是所有关于多项式 $h(X)$ 的评估都是正确的。而为了使算法在不完美的重构盒中仍能工作，这些重构盒只能以某种非可忽略的概率输出正确的重构秘密，我们需要一个额外的想法。这是因为标准的带有错误评估的多项式插值可能会失败，或者给出错误的多项式。

为了解决这个问题，我们观察到，从带有错误的评估点集合中插值出一个有界度数的多项式的问题等价于 Reed-Solomon 码的列表解码问题 $$66, 43$$。具体来说，给定一组评估点 $\{(x'_j , z_j )\}$，列表解码算法会输出所有符合特定评估点比例的多项式的列表。我们在定义 10 中正式定义了 Reed-Solomon 码的列表解码问题。

---
**定义 10 (RS 列表解码问题)** 令 $F$ 是一个有限域，$k, N, C \in \mathbb{N}$，且满足 $C \leq N < |F|$。列表解码问题定义如下：给定 $k$、$C$ 和 $N$ 对元素 $\{(x_i, y_i)\}_{i\in[N]} \subseteq F^2$，输出所有与至少 $C$ 对 $(x_i, y_i)$ 相符的、最多为 $k$ 次的单变量多项式的列表 $H$。具体来说：

$$H = \{h \in F[X] : \deg(h) \leq k \ \wedge \ |\{j \in [N] : h(x_j ) = y_j\}| \geq C \}$$

我们的方案在黑盒的方式中使用了 Reed-Solomon 码的列表解码。为具体起见，我们在定理 1 中考虑了经典的 Guruswami-Sudan 列表解码算法 $$43$$，但任何能够在多项式时间内解决定义 10 中的 Reed-Solomon 列表解码问题的算法也都可以使用。

---
#### 定理 1（Guruswami-Sudan [43]）
设 $F$ 为一个有限域，且 $k, N, C \in \mathbb{N}$，满足 $C \leq N < |F|$ 且 $C \geq \sqrt{kN}$。那么，存在一个算法 $D_{GS}$，可以在时间复杂度为 $N$、$k$ 和 $\log |F|$ 的多项式时间内解决定义 10 中的列表解码问题。由于解码算法在多项式时间内运行，其输出的列表 $H$ 的长度也是多项式的（详见 [37]）。我们用 $\tau (N, k, \log |F|)$ 来表示这个列表长度的多项式上界$^7$。

##### 追踪算法
完整的追踪算法通过获取上一节描述的多项式 $h(X)$ 的一组评估值开始。但随后，它并不进行精确的多项式插值，而是运行列表解码算法来获得候选多项式的列表。我们逐一对列表中的每个多项式进行因式分解。对于每一个多项式，我们检查它的所有根是否都属于所有参与方的真实 $x_i$ 值的列表中。以高概率，列表中只有一个多项式会满足这个条件。这个多项式的根将因此帮助我们识别出我们的“叛徒”。我们在图 4 中正式描述了追踪算法。该算法由 $N$ 和 $C$ 参数化（这些参数用于 Guruswami-Sudan 解码），我们将在本节后续讨论如何设置这些参数。

---
![[Trace.png]]


---
#### 定理 2
对于任意对手 $A$，对于任意 $\lambda \in \mathbb{N}$，对于任意 $N, C \in \mathbb{N}$ 和 $\epsilon \in (2(N + f + t^2)p, 1)$，且满足 $\epsilon > \frac{p^2 C}{N}$ 以及 $\sqrt{f N} \leq C \leq N < p$，有：

$$Adv^{\text{uni-trac}}_{A,TS,\epsilon}(\lambda) \leq e^{-\epsilon^2 N^2 \cdot (1 - \frac{1}{r})^2} + f \cdot n \cdot \tau / p$$

其中：
- $p = |F|$；
- $r = \frac{\epsilon^2 N^2}{C}$；
- $n = n(\lambda)$，$f = f(\lambda)$ 分别是参与方数量和腐败数量的上界；
- $\tau = \tau(N, f, \log p)$ 是 Guruswami-Sudan 算法输出长度的多项式上界。

---
参数 $N$ 和 $C$ 可以设置为使得对手的优势指数级地小，同时满足列表解码的约束。具体地，对于 Guruswami-Sudan 算法，$C$ 可以设置为 $C = \lceil \sqrt{N f} \rceil$，而 $N$ 可以设置为 $N = \lceil \frac{16 f \lambda}{\epsilon^4} \rceil$，其中 $\lambda$ 是安全参数。注意在这种情况下，$r \geq 2$，因此项 $e^{-\epsilon^2 N^2 \cdot (1 - 1/r)^2}$ 至多为 $e^{-\epsilon^2 N/8}$。此外，由于 $N \geq 8\lambda / \epsilon^2$，因此对手的优势有如下上界：

$$e^{-\lambda} + \frac{f \cdot n \cdot \tau}{p}$$

只要 $p$ 是相对于 $\lambda$ 的超多项式，这个优势就是关于 $\lambda$ 可忽略的。


---
##### 学习 $f$
如果追踪算法事先不知道腐败方的数量 $f$，它可以通过简单地尝试 $f = t - 1, t - 2, \ldots$，直到找到一个可以工作的 $f$ 值来学习该参数；也就是说，找到一个 $f$ 使得上述追踪算法确实能找到恰好 $f$ 个被破坏的 $x_i$ 值。假设实际的腐败数量为 $f^*$。对于每一个 $f > f^*$ 的值，追踪算法 $\text{Trace}$ 试图输出一个大小为 $f$ 的子集 $I$，这意味着它将输出至少一个诚实的参与方。

根据定理 2 的证明分析，对于输出这样一个包含至少一个诚实参与方的子集，其概率至多为 $f \cdot (n - f) \cdot \tau / p \leq n^2 \tau / p$。此外，当 $\text{Trace}$ 尝试 $f = f^*$ 时，根据定理 2，其无法输出正确子集的概率至多为 $e^{-\lambda} + n^2 \tau / p$（对于上述参数选择）。

因此，通过联合界的使用，追踪算法成功追踪到 $R$ 中腐败子集的概率至少为：

$$1 - (e^{-\lambda} + 2n^3 \tau / p)$$

---
### 3.3 增加不可归责性
现在我们介绍为了使我们的可追踪 Shamir 方案 TS 满足对恶意追踪者的**不可归责性**而需要进行的更改。这些更改将基于 Shamir 秘密共享机制，得出一个完善的可追踪秘密共享方案。

在前面几节中所描述的简化方案中，由于追踪密钥 $tk$ 明确包含了 $x_1, \ldots, x_n$，这使得恶意追踪者可以通过将某个 $x_i$ 包含在证明 $\pi$ 中，错误地指控任意一个参与方 $i$。为了解决这个问题，我们需要**预先隐藏**这些 $x_i$，但同时又使得追踪者（以及后来的验证者）可以将从重构盒 $R$ 中提取的 $x_i$ 关联回原参与方 $i$。因此，我们不再在追踪密钥和验证密钥中直接包含 $x_1, \ldots, x_n$，而是包含 $F(x_1), \ldots, F(x_n)$，其中 $F$ 是一个**单向函数**。证明仍然由腐败方的 $x_i$ 组成。这样，直观地说，错误指控一个诚实的参与方 $i$ 就相当于对随机选择的 $x_i$ 进行单向函数 $F$ 的求逆。

具体来说，对方案的更改如下：

> [!NOTE]
> 1. **共享算法的更改**  
>    共享算法 Share($1^\lambda, s, n, t, \rho$) 现在也计算 $u_i \gets F(x_i)$。追踪密钥成分 $tk_i$ 和验证密钥成分 $vk_i$ 设为 $tk_i = vk_i = u_i$（而不是原来的 $x_i$）。
> 
> ---
> 2. **追踪算法的更改**  
>    追踪算法 Trace 计算多项式列表 $H = \{h_j\}_j$ 与之前相同。对于每一个 $j$，Trace 现在通过对 $h_j$ 进行因式分解来找到它的根 $w_1, \ldots, w_f$，并检查 $h_j$ 是否为正确的多项式。然后，对于每个 $i \in [f]$，计算 $u'_i \gets F(w_i)$，并在追踪密钥 $tk$ 中查找 $u'_i$。如果对于某个索引 $i \in [f]$，$u'_i$ 没有出现在追踪密钥 $tk$ 中，那么 Trace 就从列表 $H$ 中移除 $h_j$。假设在这个过程结束时，列表 $H$ 中至少剩下一个多项式。设 $h^*$ 为列表 $H$ 中的第一个多项式，其根为 $w^*_1, \ldots, w^*_f$。对于每个 $i \in [f]$，Trace 找到索引 $k \in [n]$，使得 $F(w^*_i) = u_k$，并将 $k$ 加入到腐败方子集 $I$ 中。证明 $\pi$ 被设置为 $(w^*_1, \ldots, w^*_f)$。
> 
> 3. **验证算法的更改**  
>    要验证一个证明 $\pi = \{w_1, \ldots, w_f\}$ 是否与子集 $I = \{i_1, \ldots, i_f\}$ 一致，验证算法 Verify 检查对于 $j \in [f]$，$F(w_j) = u_{i_j}$，其中验证密钥为 $vk = (u_1, \ldots, u_n)$。

我们将结果方案记作 NITS（代表“不可归责的可追踪 Shamir”，即 "Non-Imputable Traceable Shamir"）。下面的定理建立了其不可归责性。

---
#### 定理 3
对于每一个针对 NITS 不可归责性的对手 $A$，存在一个算法 $B$，使得对于任意 $\lambda \in \mathbb{N}$，成立如下等式：

$$Adv^{\text{ni}}_{A, NIT, B}(\lambda) = \Pr[F(B(F(x^*))) = F(x^*)]$$

其中，$x^* \gets F$，概率也包含算法 $B$ 的随机选择。

---

**证明**：
设 $A$ 如同定理陈述中所述，并考虑以下尝试反转 $F$ 的对手 $B$。反转器 $B$ 以 $u^* = F(x^*)$ 作为输入，$x^*$ 是从均匀分布的 $F_p$ 中随机选择的。然后它模拟不可归责性实验 $\text{Exp}^{\text{NI}}_{A, NITS}(\lambda)$ 给对手 $A$：

1. $B$ 调用 $A(\lambda)$，并从 $A$ 得到 $n, t, i^*$ 和秘密 $s$。

2. $B$ 采样一个相关字符串 $\rho = (a_1, \ldots, a_{t-1}) \gets F^{t-1}$。它定义多项式 $q(X) = s + \sum_{i=1}^{t-1} a_i X^i$。

3. 对于每个 $i \in [n] \setminus \{i^*\}$，$B$ 采样 $x_i \gets F$。

---
4. 然后，$B$ 生成秘密份额、追踪密钥和验证密钥，并传递给 $A$：
   - **生成每个 $i \in [n] \setminus \{i^*\}$ 的秘密份额**：$B$ 计算 $y_i \gets q(x_i)$，并设 $sh_i = (x_i, y_i)$。注意，$B$ 不需要将参与方 $i^*$ 的秘密份额传递给 $A$。
   - **生成追踪密钥 $tk$ 和验证密钥 $vk$**：
     - 对于每个 $i \in [n] \setminus \{i^*\}$，$B$ 计算 $u_i \gets F(x_i)$，并设 $tk_i = vk_i = u_i$。
     - 对于参与方 $i^*$，$B$ 设 $tk_{i^*} = vk_{i^*} = u^*$。
     - 追踪密钥为 $tk = (tk_1, \ldots, tk_n)$，验证密钥为 $vk = (vk_1, \ldots, vk_n)$。

> [!note] 
> 1. 然后，$A$ 输出一个子集 $I^*$ 和一个证明 $\pi$。如果 $i^* \in I^*$ 且 $\pi$ 被接受，那么它必须包含一个域元素 $x'$，使得 $F(x') = u^*$。因此，$B$ 输出这个 $x'$。如果 $A$ 没有输出满足这些条件的 $I^*$ 和 $\pi$，$B$ 就中止。

> [!份额横坐标没有公布？]
> 观察到，$B$ 完美模拟了 $\text{Exp}^{\text{NI}}_{A, NITS}(\lambda)$ 给 $A$。此外，$B$ 仅当 $A$ 输出一个包含 $i^*$ 的子集并给出一个接受的证明时，才输出 $u^*$ 的前像。因此：

$$Adv^{\text{ni}}_{A, NIT, B}(\lambda) = \Pr[F(B(F(x^*))) = F(x^*)]$$

---
#### 随机评估点的采样
每个参与方 $i$ 的评估点 $x_i$ 可以从域 $F$ 的一个子集中采样，只要这个集合足够大以满足追踪安全性和不可归责性。具体来说，追踪算法通过列表解码算法生成一组“候选多项式”。为了确保这些多项式中没有一个包含未被破坏的参与方的 $x$ 值作为根，我们利用了这些值是从一个**超多项式大小**的集合中选择的这一事实。

同样地，为了满足不可归责性，我们需要单向函数的评估 $F(x_i)$ 能够隐藏 $x_i$，这意味着评估点必须从一个**超多项式大小**的集合中抽取。